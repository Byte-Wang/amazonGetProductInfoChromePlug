// ───────────────────────────────────────
// 全局初始化（每轮调度开始前）
// ───────────────────────────────────────
异常SKU列表 = 新建空列表()

// 对每个待监控的 SKU 执行以下流程：
对 每个 SKU in 监控SKU列表：

    // ───────────────────────────────────────
    // 步骤1：获取实时数据
    // ───────────────────────────────────────
    当前售价 = 获取当前产品售价(SKU)
    过去24小时销量 = 获取滚动24小时销量(SKU)
    亚马逊推荐报价 = 获取亚马逊官方建议价格(SKU)
    亚马逊总费用 = 调用SP-API.getMyFeesEstimate(SKU, 当前售价)

    // 【新增】异常保护：费用 ≥ 售价 → 极可能已亏损
    如果 亚马逊总费用 >= 当前售价：
        将 SKU 加入 异常SKU列表
        记录日志("【警告】SKU {SKU}：总费用({亚马逊总费用}) ≥ 售价({当前售价})，暂停调价！")
        跳过本 SKU 的后续调价逻辑（continue）

    动态最低限价 = 亚马逊总费用 × 1.30

    // ───────────────────────────────────────
    // 步骤2：读取本地状态（从持久化存储）
    // ───────────────────────────────────────
    连续滞销小时数 = 读取本地存储(f"{SKU}.连续滞销小时数")
    上次改价时间 = 读取本地存储(f"{SKU}.上次改价时间")
    最近调价方向队列 = 读取本地存储(f"{SKU}.最近调价方向队列")  // 长度最多3，元素为 "up"/"down"

    // 更新滞销计时器
    如果 过去24小时销量 == 0：
        连续滞销小时数 = 连续滞销小时数 + 1
    否则：
        连续滞销小时数 = 0

    距上次改价已过小时数 = (当前时间 - 上次改价时间) / 3600

    // ───────────────────────────────────────
    // 步骤3：基础判断
    // ───────────────────────────────────────
    允许调价 = (距上次改价已过小时数 >= 6)
    需要降价 = (连续滞销小时数 >= 24)

    // 【新增】价格稳定期：若最近3次均为降价，则强制跳过本次调价
    价格稳定期激活 = (最近调价方向队列 长度 == 3 且 所有元素 == "down")

    // ───────────────────────────────────────
    // 步骤4：销售状态
    // ───────────────────────────────────────
    如果 过去24小时销量 >= 3：
        销售状态 = "热销"
    否则如果 过去24小时销量 > 0：
        销售状态 = "一般"
    否则：
        销售状态 = "滞销"

    // ───────────────────────────────────────
    // 步骤5：计算建议新价格
    // ───────────────────────────────────────
    建议新价格 = 当前售价  // 默认不变

    如果 销售状态 != "滞销"：
        如果 当前售价 < 亚马逊推荐报价 × 1.10：
            建议新价格 = 当前售价 × 1.03
        否则：
            建议新价格 = 当前售价 × 1.01

    否则如果 销售状态 == "滞销" 且 需要降价 == false：
        建议新价格 = 当前售价  // 观望

    否则如果 需要降价 == true 且 允许调价 == true 且 价格稳定期激活 == false：
        如果 连续滞销小时数 < 48：
            建议新价格 = 当前售价 × 0.95
        否则如果 连续滞销小时数 < 72：
            建议新价格 = 当前售价 × 0.93
        否则：
            建议新价格 = 动态最低限价

    // 否则：保持原价（包括价格稳定期激活、不允许调价等情况）

    // ───────────────────────────────────────
    // 步骤6：强制应用价格底线
    // ───────────────────────────────────────
    建议新价格 = max(建议新价格, 动态最低限价)

    // ───────────────────────────────────────
    // 步骤7：决策是否执行调价
    // ───────────────────────────────────────
    执行调价 = false
    调价方向 = ""

    如果 建议新价格 != 当前售价：
        价格变动比例 = |建议新价格 - 当前售价| / 当前售价
        如果 价格变动比例 >= 0.01：
            执行调价 = true
            调价方向 = "up" 如果 建议新价格 > 当前售价 否则 "down"

    // ───────────────────────────────────────
    // 步骤8：执行 & 更新状态
    // ───────────────────────────────────────
    如果 执行调价 == true：
        调用API更新价格(SKU, 建议新价格)
        写入本地存储(f"{SKU}.上次改价时间", 当前时间)

        // 更新调价方向队列（FIFO，最多保留3条）
        将 调价方向 加入 最近调价方向队列 末尾
        如果 最近调价方向队列 长度 > 3：
            移除队列最前面的元素
        写入本地存储(f"{SKU}.最近调价方向队列", 最近调价方向队列)

    // 更新滞销计时器（无论是否调价）
    写入本地存储(f"{SKU}.连续滞销小时数", 连续滞销小时数)

// ───────────────────────────────────────
// 步骤9：异常 SKU 汇总上报（供前端展示）
// ───────────────────────────────────────
如果 异常SKU列表 非空：
    写入全局状态("风险商品看板.SKU列表", 异常SKU列表)
    触发通知("发现 {len(异常SKU列表)} 个高风险SKU，请检查！")
否则：
    清空全局状态("风险商品看板.SKU列表")

// 流程结束，等待下一小时